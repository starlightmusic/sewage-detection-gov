# Engineering Design Document: Government Complaint Management System

## 1. Overview

This document outlines the engineering architecture, technical decisions, and data management strategy for the Government Complaint Management System. It describes the current state of the application and discusses the rationale behind the chosen technical approaches, as well as potential alternatives.

## 2. Current Architecture

The application is currently a client-side-only Single Page Application (SPA). It is composed of static HTML, CSS, and JavaScript files.

*   **Frontend:**
    *   **Framework:** Vanilla JavaScript. No external libraries or frameworks are used.
    *   **Structure:** The application logic is contained in `script.js`. It manages the UI by showing and hiding different `div` elements that act as "views" (e.g., public view, admin login, admin dashboard).
    *   **Styling:** A comprehensive stylesheet (`styles.css`) provides a responsive and modern UI.

*   **Backend & Data Storage:**
    *   **Current Implementation:** There is no backend server.
    *   **Data Persistence:** The application uses the browser's `localStorage` to store and retrieve complaint data. This means all data is stored locally on the user's machine. Image data is stored as base64-encoded strings.

## 3. Engineering Decisions and Alternatives

This section details the key engineering choices made for the current version of the product and the alternatives that were considered.

### 3.1. Frontend Development

*   **Decision:** Use **Vanilla JavaScript** for all frontend logic.
*   **Rationale:**
    *   The application's UI logic is relatively simple and can be managed effectively without the overhead of a large framework.
    *   This approach results in a fast-loading application with zero external dependencies, which is ideal for a lightweight civic tool.
    *   The existing codebase is already written in vanilla JavaScript.
*   **Alternatives Considered:**
    *   **React, Vue, or Svelte:** These frameworks provide powerful tools for building complex user interfaces. However, for this project, they would introduce a build step and a larger bundle size, which was deemed unnecessary for the current requirements.

### 3.2. Backend and Data Storage

*   **Decision:** Use the browser's **`localStorage`** for data persistence.
*   **Rationale:**
    *   This was the simplest and fastest way to create a functional prototype without setting up any server-side infrastructure.
    *   It allows for a complete end-to-end user flow (submitting and viewing complaints) to be demonstrated entirely on the client side.
*   **Alternatives Considered:**
    *   **Node.js + Express with a JSON file:** This is the proposed next step. It's a lightweight backend option that doesn't require a full database server, making it easy to set up.
    *   **Full-Stack Framework (e.g., Next.js, Django):** These are too complex for the current scale of the project.
    *   **Backend-as-a-Service (BaaS) (e.g., Firebase, Supabase):** These are excellent options for rapid development but would introduce a dependency on a third-party service.
    *   **Serverless Functions (e.g., Cloudflare Workers):** A highly scalable and cost-effective option, but with a slightly higher learning curve for managing state compared to a traditional server.

## 4. Data Management Strategy

This section addresses the safety, privacy, and scalability of the data collected by the application.

### 4.1. Data Safety

*   **Current State:** **Not Secure.** Data is stored in `localStorage`, which is unencrypted and accessible to anyone with physical or remote access to the user's browser. Image data is stored as base64 strings, which is inefficient and insecure.
*   **Risks:**
    *   Data can be easily read or tampered with.
    *   There is no backup; if a user clears their browser data, all complaints are lost.
*   **Recommendations for Future Development:**
    *   **Server-Side Storage:** All data must be moved to a secure, server-side database.
    *   **Image Handling:** Images should be uploaded to a dedicated object storage service (e.g., Cloudflare R2, AWS S3). The database should only store the URL to the image.
    *   **Authentication:** Implement robust, server-side authentication for the admin portal. Do not store credentials on the client side.

### 4.2. Data Privacy

*   **Current State:** The application collects Personally Identifiable Information (PII), including contact numbers and location details.
*   **Privacy Analysis:**
    *   Ironically, the current `localStorage`-based approach is private in that no data ever leaves the user's device.
    *   However, this is a byproduct of the technical limitation, not a feature. The system cannot function as a central repository in this state.
*   **Recommendations for Future Development:**
    *   **Privacy Policy:** A clear privacy policy must be created to inform users what data is collected and how it is used.
    *   **Access Control:** Once a backend is implemented, ensure that only authorized government officers can access the PII in the complaint data.
    *   **Data Encryption:** All data should be encrypted in transit (using HTTPS) and at rest (if the database supports it).

### 4.3. Data Scale

*   **Current Limitations:**
    *   **Storage Capacity:** `localStorage` is limited to approximately 5-10 MB per domain. Storing a few high-resolution images as base64 strings will quickly exhaust this limit.
    *   **Performance:** Retrieving and filtering a large number of complaints from `localStorage` will be slow, as it requires loading the entire dataset into memory and processing it on the client side.
    *   **Concurrency:** The system is single-user only. It cannot be used by multiple citizens or officers simultaneously.
*   **Recommendations for Future Development:**
    *   **Database:** Use a scalable database system (e.g., PostgreSQL, MongoDB) that can handle a large volume of records.
    *   **API Pagination:** The backend API should implement pagination to ensure that the admin dashboard can handle thousands of complaints without performance degradation.
    *   **Object Storage:** Use a dedicated object storage service for images, which can scale to store terabytes of data if needed.

## 5. Deployment

*   **Current Method:** The application is deployed as a static site using **Cloudflare Pages**, which is connected to a **GitHub repository**.
*   **How It Works:**
    1.  Code is pushed to the main branch of the GitHub repository.
    2.  A webhook triggers a new deployment on Cloudflare Pages.
    3.  Cloudflare builds and deploys the static files (`index.html`, `styles.css`, `script.js`) to its global edge network.
*   **Rationale:**
    *   **Simplicity:** The Git-based workflow is seamless for developers.
    *   **Performance:** Cloudflare's CDN serves the files from a location close to the user, resulting in very fast load times.
    *   **Cost:** This setup is free for most use cases and provides features like automatic HTTPS.
*   **Alternatives Considered:**
    *   **GitHub Pages:** A similar free service, but with slightly fewer features than Cloudflare Pages (e.g., advanced redirects, analytics).
    *   **Netlify/Vercel:** Both are excellent alternatives with similar Git-based workflows and strong feature sets.
    *   **AWS S3 + CloudFront:** A powerful and highly customizable solution, but significantly more complex to set up and manage.
